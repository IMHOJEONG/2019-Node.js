> 2.1.6 프로미스 

>> 자바스크립트, 노드에선 주로 비동기 프로그래밍을 함. 특히 이벤트 주도 방식 때문에 콜백 함수를 자주 사용함.
>> ES2015부터는 자바스크립트와 노드의 API들이 콜백 대신 프로미스(Promise) 기반으로 재구성됨. 
>> 콜백 헬(callback hell)을 극복했다는 평가 

~~~
const condition = true; // true면 resolve, false면 reject
const promise = new Promise((resolve, reject) =>{
    if(condition)
    {
        resolve('성공');
    }
    else{
        reject('실패');
    }
});

promise
    .then((message) =>{
        console.log(message); // 성공(resolve)한 경우 실행
    })
    .catch((error)=>{
        console.error(error); // 실패(reject)한 경우 실행 
    });
~~~

>> 프로미스에는 규칙이 존재.
    1. 먼저 프로미스 객체를 생성해준다.
    2. new Promise로 프로미스를 생성할 수 있고, 안에 resolvce와 reject를 매개변수로 갖는 콜백 함수를 넣어줌.
    3. 이렇게 만든 promise 변수에 then, catch 메서드를 붙일 수 있음.
    4. 프로미스 내부에서 resolve가 호출되면 then이 실행되고, reject가 호출되면 catch가 실행됨.
    5. resolve와 reject에 넣어준 인자는 각각 then, catch의 매개변수에서 받을 수 있는데,
        즉, resolve('성공')가 호출되면 then의 message가 '성공'이 됩니다. 
        만약 reject('실패')가 호출되면 catch의 error가 '실패'가 되는 것입니다.
    6.  then이나 catch에서 다시 다른 then, catch를 붙일 수 있음. 이전 then의 return 값을 다음 then의 매개변수로 넘김
        프로미스를 return한 경우 프로미스가 수행된 후 다음 then이나 catch가 호출됨.

~~~
    promise
        .then((message)=>{
            return new Promise((resolve, reject) => {
                resolve(message);
            });
        })
        .then((message2)=>{
            console.log(message2);
            return new Promise((resolve, reject)=>{
                resolve(message2);
            });
        })
        .then((message) =>{
            console.log(message3);
        })
        .catch((error)=>{
            console.error(error);
        });
~~~
>> 처음 then에서 message를 resolve하면 다음 then에서 받을 수 있음.
>> 여기서 다시 message2를 resolve했으므로 다음 then에서 message3를 받았음.
>> 이것을 활용해 콜백을 Promise로 바꿀 수 있음

~~~
    function findAndSaveUser(Users){
        Users.findOne({},(err,user)=>{ // 첫 번째 callback
            if(err){
                return console.error(err);
            }
            user.name = 'zero';
            user.save((err)=>{ // 두 번째 callback 
                if(err)
                {
                    return console.error(err);
                }
                Users.findOne({gender: 'm' },(err, user)=>{
                    // 세 번째 callback
                    // 생략 
                });
            });
        });
    }
~~~
>> 콜백 함수가 세 번 중첩되어 있고, 콜백 함수가 나올 때마다 코드의 깊이가 깊어짐
>> 각 콜백 함수마다 에러도 따로 처리해주어야 합니다. 

~~~
    function findAndSaveUser(Users){
        Users.findOne({})
            .then((user)=>{
                user.name = 'zero';
                return user.save();
            })
            .then((user)=>{
                return Users.findOne({gender:'m'});
            })
            .then((user)=>{
                // 생략
            })
            .catch(err=>{
                console.error(err);
            });
    }
~~~

>> 코드의 깊이가 더 이상 깊어지지 않음. then 메소드들은 순차적으로 실행됨.
>> 콜백에서 매번 따로 처리해야 했던 에러도 마지막 catch에서 한번에 처리할 수 있음.
>> But, 모든 콜백 함수를 위와 같이 바꿀 수 있는 것은 아님.
>> 메소드가 프로미스 방식을 지원해야 함. 예제의 코드는 findOne과 save 메소드가 내부적으로 프로미스
>> 객체를 가지고 있어서 가능했던 것.
>> 지원하지 않는 경우도 바꿀 수 있긴 하다.

>> 프로미스 여러 개를 한 번에 실행할 수 있는 방법 존재 
>> 기존의 콜백 패턴처럼 콜백을 여러 번 중첩해서 사용해야 했을 거지만,
>> Promise.all을 활용하면 간단히 할 수 있음.

~~~
    const promise1 = Promise.resolve('성공1');
    const promise2 = Promise.resolve('성공2');
    Promise.all([promise1,promise2]);
        .then((result)=>{
            console.log(result); // ['성공1','성공2']
        })
        .catch((error)=>{
            console.log(error);
        });
~~~

>> Promise.resolve : 즉시 resolve하는 프로미스를 만드는 방법
>> 비슷한 것으로 즉시 reject하는 Promise.reject도 있음.
>> 프로미스가 여러 개 있을 때 Promise.all에 넣으면 모두 resolve될 때까지 기다렸다가 then으로 넘어감
>> Promise 중 하나라도 reject가 되면 catch로 넘어감.
