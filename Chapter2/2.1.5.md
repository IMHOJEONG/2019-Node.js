> 2.1.5 비구조화 할당 

>> 이름은 어색하지만 매우 유용한 기능, 객체와 배열로부터 속성이나 요소를 쉽게 꺼낼 수 있음
~~~
    var candyMachine = {
        status:{
            name: 'node',
            count: 5,
        },
        getCandy: function(){
            this.status.count--;
            return this.status.count;
        }
    };
    var getCandy = candyMachine.getCandyl
    var count = candyMachine.status.count;
    // 객체의 속성을 같은 이름의 변수에 대입하는 코드
~~~
~~~
    const candyMachine={
        status: {
            name:'node',
            count:5,
        },
        getCandy(){
            this.status.count--;
            return this.status.count;
        }
    };
    const { getCandy, status: { count }} = candyMachine;
~~~

>> 당황스럽겠지만, 위 문법은 유효함, candyMachine 객체 안의 속성을 찾아서 변수와 매칭해줌
>> count 처럼 여러 단계 안의 속성도 찾을 수 있음.
>> getCandy와 count 변수가 초기화된 것 

>> 배열도 비구조화 가능 
~~~
    var array = ['nodejs',{},10,true];
    var node = array[0];
    var obj = array[1];
    var bool = array[array.length-1];
    // array란 배열의 첫 번째, 두 번째 요소와 마지막 요소를 변수에 대입하는 코드입니다.
    // 다음과 같이 변경 가능
    const array = ['nodejs',{},10,true];
    const [node,obj, ,bool] = array;
~~~
>> 어색해 보이지만, 나름대로 규칙이 존재 => node, obj와 bool의 위치를 보면 node는 배열의 첫 번째 요소,
>> obj는 두 번째 요소, bool은 마지막 요소라는 것을 알 수 있음. obj와 bool 사이의 요소들은 무시

>> 비구조화 할당 문법 : 코드 줄 수를 상당히 줄여주므로 유용
>> 특히 노드는 모듈을 사용하므로 이러한 방식을 자주 사용 

