> 2.1.7 async/await

>> 노드 7.6 버전부터 지원되는 기능, 비동기 프로그래밍을 해야할 때 도움이 많이 됨.
>> 프로미스가 콜백 지옥을 해결 => But, 코드가 장황, async/await 문법은 프로미스를 사용한 코드를 한 번 더 깔끔하게 줄여줌.

~~~
    function findAndSaveUser(Users){
        Users.findOne({})
            .then((user)=>{
                user.name = 'zero';
                return user.save();
            })
            .then((user)=>{
                return Users.findOne({gender:'m'});
            })
            .then((user)=>{
                // 생략
            })
            .catch(err=>{
                console.error(err)
            }); 
    }
~~~
>> 콜백과 다르게 코드의 깊이가 깊진 않지만, 코드 길이는 여전히 김
>> async/await 문법을 사용한다면?

~~~
    async function findAndSaveUser(Users)
    {
        let user = await Users.findOne({});
        user name = 'zero';
        user = await user.save();
        user = await Users.findOne({gender:'m'});
        // 생략
    }
~~~
>> 놀라울 정도로 코드가 짧아졌는데, 함수 선언부를 일반 함수 대신 async function으로 교체한 후,
>> 프로미스 앞에 await을 붙여주었습니다. 
>> 이제 함수는 해당 프로미스가 resolve될 떄까지 기다린 뒤 다음 로직으로 넘어감.
>> ex) await Users.findOne({})이 resolve 될 때까지 기다린 뒤, user 변수를 초기화하는 것

>> 위 코드는 에러를 처리하는 부분이 없어 추가 작업이 필요
~~~
    async function findAndSaveUser(Users)
    {
        try{
            let user = await Users.findOne({});
            user.name = 'zero';
            user = await user.save();
            user = await Users.findOne({gender:'m'});
            
        }catch(error)
        {
            console.log(error);
        }
    }
~~~

>> try catch문으로 로직을 감쌌는데, 프로미스의 catch 메서드처럼 try/catch문의 catch가 에러를 처리
>> 화살표 함수도 async와 같이 사용할 수 있음.

~~~
    const findAndSaveUser = async (Users) => {
        try {
            let user = await Users.findOne({});
            user.name = 'zero';
            user = await user.save();
            user = await Users.findOne({gender:'m'});

        }

        catch(error){
            console.error(error);
        }
    }
~~~
>> for 문과 async/await을 같이 써서 Promise.all을 대체할 수 있음 
>> 이것은 노드 10버전 부터 지원하는 ES2018문법 

~~~
    const promise1 = Promise.resolve('성공1');
    const promise2 = Promise.resolve('성공2');
    (async ()=>{
        for await (promise of [promise1, promise2]){
            console.log(promise);
        }
    });
~~~

>> Promise.all 대신 for await of 문을 사용해서 프로미스를 반복하는 모습 
>> 앞으로 중첩되는 콜백 함수가 있다면 프로미스를 거쳐 async/await 문법으로 바꾸는 연습을 해보자
>> 코드가 휠씬 간결해질 것 
