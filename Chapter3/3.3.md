> 3.3 모듈로 만들기 

>> 노드는 코드를 모듈로 만들 수 있다는 점에서 브라우저의 자바스크립트와는 다름
>> 모듈 : 특정한 기능을 하는 함수나 변수들의 집합
>> 자체로도 하나의 프로그램이면서 다른 프로그램의 부품으로도 사용가능
>> 
>> 모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있음
>> 자바스크립트에서 코드를 재사용하기 위해 함수로 만드는 것과 비슷.
>> 보통 파일 하나가 모듈 하나가 됨.
>> 파일별로 코드를 모듈화할 수 있어 관리하기 편리
>> => 브라우저도 모듈을 지원합니다. (Chrome 60버전 이후)

~~~
    const odd = '홀수입니다.';
    const even = '짝수입니다.';

    module.exports = {
        odd,
        even
    };
~~~

>> var.js에 변수 두 개를 선언, module.exports에 변수들을 담은 객체를 대입 => 이 파일을 모듈로서 기능 
>> 변수들을 모아둔 모듈이 되는 것 => 다른 파일에서 이 파일을 불러오면 module.exports에 대입된 값 사용 가능

~~~
    const {odd , even} = require('./var');

    function checkOddOrEven(){
        if(num % 2){ // 홀수면
            return odd;
        }
        else{
            return even;
        }

    }

    module.exports = checkOddOrEven;
~~~

>> require 함수 안에 불러올 모듈의 경로를 적어줌, 위 예제는 같은 폴더 안에 파일을 만들었지만,
>> 다른 폴더에 있는 파일도 모듈로 사용할 수 있습니다. => require 함수의 인자로 제공하는 경로만 잘 지정해주면 됨.
>> 파일 경로에서 js나 json 같은 확장자는 생략이 가능하다. 

>> 예제 코드 : require 함수로 var.js에 있던 값들을 불러오고 있음 
>> const {odd, even} => ES2015+ 문법 
>> var.js의 module.exports에 담겨 있던 객체를 불러와 func.js에서 사용하는 모습

>> var.js에서 변수를 불러온 뒤, 숫자의 홀짝을 판별하는 함수를 선언함. 그리고 다시 module.exports에 함수를 대입 
>> => 다른 모듈(var.js)을 사용하는 파일을 다시 모듈(func.js)로 만들 수 있음 
>> module.exports에는 객체만 대입해야 하는 것이 아니라 함수 or 변수를 대입해도 됨.

~~~
    const { odd, even } = require('./var');
    const checkNumber = require('./func');

    function checkStringOddOrEven(str) {
        if (str.length % 2) // 홀수면
        {
            return odd;
        } else {
            return even;
        }
    }

    console.log(checkNumber(10));
    console.log(checkStringOddOrEven('hello'));
~~~

>> index.js : var.js와 func.js를 모두 참조 => 모듈 하나가 여러 개의 모듈을 사용할 수 있는 것 
>> => var.js가 func.js와 index.js에 두 번 쓰이는 것 -> 모듈 하나가 여러 개의 모듈에 사용될 수 있음.
>> 모듈로부터 값을 불러올 때 변수 이름을 다르게 지정할 수도 있음
>> ex) func.js의 checkOddOrEven이 checkNumber라는 이름으로 사용되고 있음.

~~~
    $ node index  // index.js의 실행 
~~~ 

>> 이렇게 여러 파일에 걸쳐 재사용되는 함수나 변수들을 모듈로 만들어두면 편리
>> But 모듈이 많아지고 모듈 간의 관계가 얽히게 되면 구조를 파악하기 어렵다는 단점도 존재
>> 노드에서는 대부분이 파일이 다른 파일을 모듈로 사용하고 있음 => 모듈을 만들고 사용하는 방법을 꼭 알아두어야 함.

> ES2015 모듈 

>> ES2015가 도입되면서 자바스크립트도 자체 모듈 시스템 문법이 생김 => 노드의 모듈 시스템과는 문법이 조금 다름 
~~~
    // func.mjs => 본문의 func.js를 바꾸어 보면
    import { odd, even } from './var';
    
    function checkOddOrEven(num){
        if(num % 2)
        {
            return odd;
        }
        else{
            return even;
        }
    }

    export default checkOddOrEven;
~~~

>> require와 module.exports가 import, export default로 바뀌었음. => 사소한 차이가 있음
>> + 노드에서도 9버전부터 ES2015의 모듈 시스템 사용가능 
>> => 하지만, 파일의 확장자를 mjs로 지정해야 하고, 실행 시 node --experimental-modules 파일명 처럼
    특별한 옵션을 붙여주어야 한다는 제한 존재

>> 방금 썻던 require 함수, module 객체는 따로 선언하지 않았지만 사용할 수 있었어.
>> 어떻게 가능한가? 바로 노드에서 기본적으로 제공하는 내장 객체!
